
import Html exposing (..)
import Html.App as Html
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Json.Decode as Json exposing ((:=))
import String
-- import Mouse exposing (Position)

-- TODO: incorporate 

main =
  Html.program 
    { init = init
    , view = view
    , update = update
    , subscriptions = subscriptions
    }


-- MODEL

{-| 
taysar hole = (body header hole footer)
welcome = (p "welcome")
blog hole = (main header hole footer)
articles = (div article ...)

(body header (list welcome (blog (list (articles)))) footer)

A scrap accepts a list of scraps|html and a query object and returns html.
All the scraps and subscraps get flattened then evaluated at runtime.
A page accepts a query object and returns html.
The query object only materializes on the front-end, except for demo purposes in the builder.

The recursive scraps that the user builds are no longer scraps! 
They are different in nature from the raw things found in aiport-scrap-*.
scrap = stuff->args->html, but we're saving args->html

page_db = { scrap_id: 1, stuff: [ { scrap_id: 2, stuff: [ "title" ] }, "hello", "world" ] }
-}

type alias Model = 
    { pages: List Page
    -- , page: Page
    -- , scraps: List Scrap
    }
    
type alias Page =
    { route: Maybe String
    , pagelets: List Pagelet
    }
    
type alias Pagelet =
    { scrap: Scrap
    -- , stuff: List Pagelet
    }
    
-- lazy?
-- type alias Scrap a b = a -> b -> Html Msg
type alias Scrap = Html String
    
emptyModel : Model
emptyModel =
   { pages = []
   } 
    
init : Model -> ( Model, Cmd Msg )
init savedModel =
    emptyModel savedModel ! []
    
-- UPDATE

type Msg = ViewPage Page

update : Msg -> Model -> Model
update msg model =
    case msg of
        ViewPage page -> { model | page = page }


-- SUBSCRIPTIONS

subscriptions = \_ -> Sub.none

-- VIEW

view : Model -> Html Msg
view model =
    div
        [
        ]
        [ aside [] (pageNav model.pages)
        , article [] pageBuild
        , aside [] scrapNav
        ]

pageNav pages =
    ul [] (List.map (\{l} -> li [] [l]) ((pagesLinks pages) ++ [newPageLink]))
        
pagesLinks pages =
    List.map pageLink pages
        
pageLink page = 
    a [onClick (ViewPage page)] [ text page.route ]
        
newPageLink =
    a [onClick (ViewPage { route = Nothing, scrap = [] }) ] [ text "+ New Page" ]
        
-- TODO
pageBuild page =
    []

-- TODO
scrapNav =
    []
